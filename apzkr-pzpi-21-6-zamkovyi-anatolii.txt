МІНІСТЕРСТВО ОСВІТИ І НАУКИУКРАЇНИ
Харківський національний університет радіоелектроніки
Кафедра програмної інженерії




КУРСОВА РОБОТА
ПОЯСНЮВАЛЬНА ЗАПИСКА

з навчальної дисципліни «Архітектура програмного забезпечення»
Тема роботи: Програмна система для організації спортивних змаганнь
З академічного веслування

                       Студент гр. ПЗПІ-21-6		 __________________ Замковий А.Г.(підпис)
Керівник роботи 			___________________ ст.викл. Сокорчук І.П.
(підпис) 
Роботу захищено «__»_________2024 р.
з оцінкою _________________________ 

Комісія: 		___________________ доц. Лещинський В.О. 
(підпис)
___________________ доц. Лещинська І.О. 
(підпис)
___________________ ст.викл. Сокорчук І.П.
(підпис)                                                                                                




Харків 2024
Харківський національний університет радіоелектроніки


Факультет комп’ютерних наук	Кафедра програмної інженерії	
Спеціальність 121 – Інженерія програмного забезпечення	
Курс	3	Семестр	5	 
Навчальна дисципліна Архітектура програмного забезпечення                             

ЗАВДАННЯ
НА ЛАБОРАТОРНІ РОБОТИ СТУДЕНТОВІ


1.Тема проєкту: Програмна система організації спортивних змагань з академічного веслування	
2.Термін узгодження завдання з лабораторних робіт «4	»     квітня	2024 р.
3.Термін здачі завдання з лабораторних робіт «6»    червня	2024 р.
1.Вихідні дані до проєкту: програмна система, яка є унікальною, складається з багатьох елементів, підтримує масштабованість, може бути монетизованою, програмна система вирішує актуальну проблему сьогодення, орієнтована на масову аудиторію. Програмна система інтернаціоналізована, локалізована та забезпечує захист персональних даних. Складається з серверної,	мобільної,	клієнтської	та	IoT	частини.


2.Зміст звітів з лабораторних робіт (перелік питань, що належить розробити) Vision and Scope документ, серверна (back-end частина) системи, програмне забезпечення для IoT або SmartDevice пристрою, клієнтська (front-end частина) програмної системи, мобільний програмний застосунок	
3.Перелік графічного матеріалу (діаграми, рисунки, інтерфейси):	UML діаграма розгортання, UML діаграма прецедентів, ER-модель даних, UML діаграма станів, UML діаграма взаємодії, UML діаграма діяльності, копії екранів («скріншоти») прикладної програми, приклади звітів прикладної програми















КАЛЕНДАРНИЙ ПЛАН


№	Основні етапи виконання проєкту
в рамках лабораторних робіт	Термін виконання
етапів	Примітка
1	Функціональна специфікація 
програмного проекту	 4 квітня 
2024 року		
2	Проектування програмного 
проекту	15 квітня
2024 року		
3	Кодування програмного проекту	1 травня 
2024 року	
4	Оформлення пояснювальної 
записки	30 травня 
2024 року	
5	 Захист курсової роботи	14 червня 
2024 року		

Дата видачі теми проєкту «4»	квітня    2024 р.


Керівник                                           	                     ст. викл. Сокорчук І.П.                              
(підпис)

Завдання прийняв до виконання
ст.гр. ПЗПІІ-21-6	                        Замковий А.Г.
(підпис)


ЗМІСТ
1. АНАЛІЗ ПРЕДМЕТНОЇ ОБЛАСТІ 6
1.1. Загальний огляд 6
1.2. Аналіз існуючих аналогів 6
1.3 Потреби потенційних користувачів 6
2. ПОСТАНОВКА ЗАВДАННЯ 10
2.1. Бачення програмної системи 10
2.2. Основні функції системи 10
2.3. Обсяг початкового випуску 12
2.4	 Обсяг наступних випусків 16
2.5	 Обмеження та винятки 16
2.6	 Робоче середовище 17
3. АРХІТЕКТУРА ТА ПРОЄКТУВАННЯ СИСТЕМИ 20
3.1. Опис загальної архітектури системи 20
3.2. Архітектура серверної частини 20
3.3. Архітектура клієнтської частини 22
3.4	 Архітектура програмного забезпечення для розумних пристроїв 23
3.5 Архітектура мобільного застосунку 24
4. РЕАЛІЗАЦІЯ ПРОГРАМНОЇ СИСТЕМИ 26
4.1	Реалізація серверної частини 26
4.2 Реалізація клієнтської частини 26
4.3.Реалізація програмного забезпечення для розумних пристроїв 27
4.4 Реалізація мобільного застосунку 28
5.ОПИС СТВОРЕНОЇ СИСТЕМИ 29
5.1	Опис серверної частини 29
5.2	Опис клієнтської частини 30
5.3	Опис взаємодії з розумними пристроями 31
5.4	Опис взаємодії з мобільним застосунком 33
ВИСНОВОК 38
ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ	39
ДОДАТОК А	40
ДОДАТОК Б	61
ДОДАТОК В	72
ДОДАТОК Г	77








1 АНАЛІЗ ПРЕДМЕТНОЇ ОБЛАСТІ
1.1 Загальний огляд
На сьогоднішній день немає програми для організації спортивних змагань для академічного веслування на різних етапах: від вирішення організайних питаннь до проведення та оголошення результатів змагань. Тому Tournament Planner має дати змогу користувачам планувати змагання в різні календарні дні , проводити їх та формувати результати.
Даний продукт дозволить організаторам легко проводити спортивні змагання з веслування в різних класах човнів, а спортсменам та тренерам зручний інтерфейс перегляду календарю змаганнь та результатів.

1.2 Аналіз існуючих аналогів
На сьогодні немає повноцінного аналогу для данної системи: усі програмні системи пов’язані або не з проведенням змагань, а з організацією спортивного процесу або лише для окремих видів змаганнь з веслування (наприклад на тренажері https://www.concept2.com/service/software/ergdata ), тому ніша данної системи є незайнятою і доволі перспективною. У майбутньому проєкт може приносити прибуток, наприклад у формі підписки.

1.3 Потреби потенційних користувачів
Потреби тренерів

Управління командами: Тренери потребують інструментів для створення та управління своїми спортивними командами. Це включає можливість створювати списки спортсменів.

Перегляд результатів: тренери повинні мати змогу бачити результати різних змаганнь з можливістю пошуку, фільтрації своїх спортсменів.
 
Потреби учасників

Реєстрація та участь: Учасники спортивних подій потребують можливості швидко та зручно реєструватися на змагання та бачити деталі свого старту, бачити час старту інших. Вони хочуть отримувати деталі подій.

Оновлення та повідомлення: Учасники бажають отримувати оновлення та повідомлення щодо подій, такі як зміни в розкладі, результати і важливі анонси.

Доступ до інформації: Інформація про події, включаючи розклад, місцезнаходження та правила, повинна бути доступною для учасників. Вони потребують легкого доступу до всієї необхідної інформації.

Потреби глядачів

Отримання інформації: Глядачі бажають отримувати інформацію про спортивні події, включаючи розклад, місцезнаходження та результати. Вони хочуть бути в курсі всіх аспектів подій.

Живі оновлення: Глядачі очікують можливості отримувати живі оновлення під час подій, такі як результати жеребу, результати заїздів. Це дозволить їм насолоджуватися подіями в режимі реального часу.

Отримання квитків: Глядачі повинні мати можливість отримати швидку інформацію про вартість та доступність квитків.

Незадоволені потреби ринку

Інтеграція з соц мережами: користувачі мають мати можливість поширювати інформацію про найближчі змагання через соц мережі.
Кастомізація: Багато клієнтів шукають можливості кастомізації для пристосування системи до своїх конкретних потреб у сфері спорту та подій. Існуючі системи часто мають обмежену гнучкість у цьому плані.

Аналітика та звіти: Організатори спортивних подій можуть потребувати розширеної аналітики та звітів для оцінки вдачі подій та виявлення можливостей для покращення організації майбутніх змагань.

Апаратне та програмне забезпечення

Система повинна бути доступною на різних пристроях, включаючи настільні комп'ютери, планшети та смартфони. Вона повинна бути сумісною з поширеними веб-браузерами, такими як Chrome, Firefox, Safari та Edge. Також може бути розглянуто можливість розробки мобільних додатків для платформи Android.

Критичні вимоги інтерфейсу та продуктивності

Інтеграція з базою даних: Система повинна безперешкодно інтегруватися з базою даних для зберігання та отримання інформації про події, користувачів та інформацію, пов'язану з подіями.

Служби сповіщень: Ефективні служби сповіщень є важливими для надання користувачам реального часу оновлень, таких як зміни в подіях, скасування та результати.

Масштабованість: Система повинна бути здатною обробляти зростаючу кількість користувачів та подій без втрати продуктивності.





















2 ПОСТАНОВКА ЗАВДАННЯ
2.1 Бачення програмної системи
Наша місія полягає в створенні інноваційної системи для організації спортивних подій, яка змінює спосіб, яким світ сприймає та бере участь у спортивних змаганнях. Ми прагнемо створити сучасну, доступну та легко використовувану платформу, яка об'єднує організаторів, учасників та глядачів у спільному спортивному досвіді.

Даний продукт дозволить спортсменам та тренерам зручний засіб для перегляду змаганнь в яких вони приймають участь, організаторам застосунок для зручного планування змаганнь з  та запрошеннь на них учасників, створення гоночних заїздів, а фанатам зручний інтерфейс для перегляду найближчих подій.
2.2 Основні функції системи

MF-1: Управління подіями: Система дозволяє організаторам створювати, планувати та керувати спортивними змаганнями. Реалізація цієї функціональності потребує валідації та підтвердження реєстрації учасників на події, зберігання даних про учасників, дані їхнього старту або заїзду.

MF-2: Реєстрація та участь: Учасники можуть швидко реєструватися на події та підтверджувати свою участь в онлайн-режимі.

MF-3: Керування командами: Тренери мають можлисть створювати та управляти спортивними командами. Це включає можливість додавання, редагування та видалення даних про команди, тренерів та учасників, а також пов'язані з цим права доступу.

MF-4: Оновлення в режимі реального часу: Глядачі та учасники можуть отримувати живі оновлення під час подій, включаючи результати заїздів, дані про наступні заїзди, статистику та коментарі. Розробка механізму отримання та відображення живих даних під час подій, що включає оновлення результатів, статистики та коментарів у режимі реального часу для глядачів та учасників.

MF-5: Сповіщення та повідомлення: Система надає можливість відправляти сповіщення та повідомлення щодо змін у розкладі, результатів та важливих анонсів. Організація системи сповіщень, що дозволяє надсилати повідомлення про зміни у розкладі, результати та важливі анонси учасникам, глядачам та організаторам.

MF-6: Доступність на різних платформах: Система доступна на різних пристроях, включаючи комп'ютери, планшети та смартфони, та підтримує популярні веб-браузери та мобільні додатки. Розробка веб-сайту та мобільних додатків, які будуть оптимізовані для користування на різних типах пристроїв і підтримуватимуть різні браузери та операційні системи.

MF-7: Підтримка мультимедійних матеріалів: Глядачі мають можлисть переглядати результати у вигляді pdf-файлів, фото- та відеоматеріали подій.
2.3	Обсяг початкового випуску

Обсяг необхідних функцій для першої версії продукту:
FE-1: Реєстрація та участь учасників у спортивних подіях.
FE-2: Керування спортивними командами для тренерів, 
FE-3:Забезпечення оновлень   під час спортивних подій, таких як  статистика та інформація про квитки.
FE-4:Сповіщення та повідомлення для користувачів щодо змін у розкладі, результатів,  та важливих анонсів про нові заїзди, результати жеребкування тощо.
FE-5: Доступність системи на різних пристроях та браузерах, включаючи  комп'ютери,  та смартфони.
FE-6: Система запрошень на змагання: організатори мають змогу запрошувати тренерів та спортсменів для участі, які у свою чергу можуть як приймати так і відхиляти запрошення.
FE-7: Автоматизоване жеребкування: система має автоматично проводити жеребкування на основі всіх зареєстрованих учасників та побажаннь організаторів.
FE-8: Автоматизовані результати: система має сама створювати фінішні протоколи на основі даних отриманих розумними пристроєм.
Опис серверних функцій для продукту з організації спортивних подій:
FE-1: Реєстрація Користувачів:
Сервер повинен надавати можливість користувачам реєструватися в системі, вказуючи необхідну інформацію, таку як ім'я, електронна пошта та пароль. Після реєстрації дані користувачів повинні бути збережені в базі даних після хешування.
FE-2:Автентифікація та Вхід:
Сервер повинен надавати можливість користувачам входити в систему, використовуючи їхні облікові дані (електронну пошту та пароль).

FE-3:Хешування та Збереження Даних:

Сервер повинен забезпечувати хешування паролів користувачів перед збереженням їх у базі даних, щоб забезпечити безпеку.
Всі дані користувачів, команд, подій та результатів повинні зберігатися в базі даних для подальшого використання та відображення.
FE-4:Створення змаганнь:
Сервер повинен надавати можливість організаторам створювати нові змагання, визначаючи список учасників, заїзди.
FE-5: Обробка результатів заїздів:
Сервер повинен мати можливість створювати результати заїздів та змаганнь у зручному для перегляду форматі та швидко використовувати дані для створення наступних заїздів.
FE-6:Відстеження Подій та Результатів:
Сервер повинен надавати інструменти для відстеження спортивних подій в режимі реального часу.
Результати подій повинні бути доступні для учасників та глядачів.
Опис функцій веб-клієнта для продукту з організації спортивних подій:
FE-1: Реєстрація та Вхід:
Користувачі повинні мати можливість реєструватися в системі та входити за допомогою своїх облікових даних (електронної пошти та пароля).
Після входу користувачам доступні особисті облікові дані та можливість налаштувань профілю.

FE-2: Перегляд календарю змаганнь:

Користувачі можуть переглядати доступні спортивні події, включаючи інформацію про них, таку як дату, час, місце, правила та умови участі.

FE-3: Реєстрація на змагання:
Спортсмени можуть реєструватися на змагання, з’явившись у стартовому протоколі.

FE-4: Відстеження Подій та Результатів:
Учасники та глядачі можуть відстежувати спортивні події в режимі реального часу, переглядати  статистику та коментарі.
Результати подій доступні для учасників та глядачів.

FE-5: Історія:
Кожен користувач має особистий кабінет, де може переглядати свою участь у минулих змаганнь та найближчі змаганння.

Функції мобільного додатку для організації спортивних подій включатимуть:
FE-1:Реєстрація та Вхід:
Користувачі зможуть реєструватися та входити в додаток за допомогою своїх облікових даних.
FE-2: Отримання Сповіщень:
Мобільний додаток надсилатиме сповіщення користувачам про нові події, запрошення, оновлення результатів та інші важливі повідомлення.
Система нотифікацій буде вбудована в додаток для сповіщення користувачів про важливі події, зміни та оновлення.
FE-3: Перегляд та Реєстрація на Події:
Користувачі зможуть переглядати доступні спортивні події та дивитися інформацію про них прямо через додаток.
FE-4: Відстеження Подій у Реальному Часі:
Мобільний додаток надасть можливість користувачам відстежувати спортивні події в режимі реального часу, отримувати , статистику та коментарі.
FE-5: Історія:
Кожен користувач має особистий кабінет, де може переглядати свою участь у минулих змаганнь та найближчі змаганння.

FE-6: Повна Інформація про Події:
У додатку буде доступна повна інформація про спортивні події, включаючи розклад, місцезнаходження, правила та результати.

FE-7: Підтримка Операційних Систем:
Мобільний додаток буде розроблений для платформи Android для забезпечення широкої доступності.
Функції розумного пристрою для організації спортивних подій включатимуть:
FE-1: Вимір результату кожного веслувальника:
Розумний пристрій дозволятиме отримувати необхідну інформацію для формування результатів таку як час, який витратив спортсмен на подолання дистанції та деякі інші корисні параметри, наприклад середня швидкість.

2.4	Обсяг наступних випусків 

Планується впровадження наступних функцій у майбутніх випусках:
FE-1: Обговорення подій у локальних та глобальних чатах.
FE-2: Використання геолокації для отримання сповіщень про найближчі події та навігації.
FE-3: Впровадження сервісів онйлан-оплати для купівлі квитків.
FE-4: Інтеграція з соціальними медіа для обміну враженнями та фотографіями під час подій.

2.5	Обмеження та винятки 

LI-1:Неможливість моментальної реалізації всіх запланованих функцій - деякі функції можуть бути додані наступними випусками або розширені в майбутньому для забезпечення стабільності та ефективності.

LI-2: Повна інтеграція з усіма існуючими спортивним організаціями може бути складною, коштувати грошей та займе багато часу.

LI-3: Розробка версій продукту для всіх можливих платформ - першочергово планується розробка веб-клієнта та мобільного додатка для Android. Версії для інших платформ можуть бути розглянуті у майбутньому.

LI-4: Велика кількість налаштувань та параметрів користувача - продукт буде надавати базовий набір налаштувань, але не планується надмірна складність налаштувань, оскільки це займе ресурси, які можна використати на важливіші функції.

EX-1: при використанні нових технологій або виборі певних стандартів, 
можуть виникнути обмеження у сумісності зі старішими версіями 
програмного забезпечення або обладнання, яке використовується у 
супермаркетах;
EX-2: певні функції або додаткові можливості можуть бути виключені з поточної версії програмної системи з метою ефективного та швидкого запуску базового функціоналу, але будуть розглядатися для включення в майбутні оновлення.

2.6	Робоче середовище 

У концепції та рамках проєкту системи організації спортивних змагань передбачається використання наступних технологій і програмних засобів:

Платформа розробки:

Серверна сторона: Використання C#та ASP.NET для створення серверної частини додатку.
Веб-інтерфейс: Розробка веб-інтерфейсу з використанням HTML, JavaScript, Blazor та CSS для відображення і взаємодії з користувачами.
Бази даних:

Система управління базами даних: Використання популярних Систем Управління Базами Даних, таких як MS SQL Server для зберігання даних про події, користувачів, команди та інші необхідні дані.
Фреймворки та бібліотеки:

ASP.NET: Використання цього фреймворку для розробки веб-додатку та реалізації бізнес-логіки. Також його буде використано для роботи з базою даних та забезпечення доступу до неї.
Мови програмування:

C#: Використання C#для розробки серверної частини.
JavaScript: Використання JavaScript, Blazor для розробки клієнтського інтерфейсу.
Kotlin: Використання Kotlin для мобільного застосунку.
Мобільний додаток:

Платформа: Розробка мобільного додатку для платформ iOS та Android за допомогою мови програмування Java.
Основні вимоги:

Доступність: Система повинна бути доступною 24/7 для користувачів з різних часових зон.
Надійність: Система повинна забезпечувати надійну роботу та захист від відмов.
Продуктивність: Максимальні часи відповіді повинні бути встановлені для забезпечення швидкості доступу до даних.
Цілісність даних: Система повинна забезпечити цілісність та конфіденційність даних користувачів та організаторів подій.














3АРХІТЕКТУРА ТА ПРОЄКТУВАННЯ СИСТЕМИ

3.1	Опис загальної архітектури системи

Програмна система складається з кількох основних компонентів, які взаємодіють між собою для реалізації централізавного та налагодженого управління даними. 
Центральний сервер є головним компонентом, що забезпечує обробку, зберігання та аналіз даних, отриманих від користувачів, або через розумний пристрій. Сервер збирає дані, зберігає їх у базі даних, маючи інструмментарій для їх зміни, обробки.  Серверна частина надає усім клієнтам інтерфейс у вигляді REST API для взаємодії, відправки та отримання даних по протоколу HTTP (HTTPS).
У системі присутній розумний ІоТ девайс, необхідний для реалізації змаганн.
Клієнтські додатки, включаючи веб-застосунок та мобільний додаток, забезпечують зручний доступ до даних системи для користувачів. 

3.2	Архітектура серверної частини



Архітектура серверної частини системи представлена ASP.NET Core MVC-застосунком та написана з використанням мови програмування C# та платформи .NET 6.

Архітектура побудована за принципами MVC (Model-View-Controller), що забезпечує чітке розділення відповідальностей між різними компонентами системи: Model, View та Controller. Кожен компонент виконує окрему роль, що полегшує підтримку, тестування та розвиток системи.

Нижче наведено детальний опис кожного з компонентів:

Model:
Цей шар містить основні доменні об'єкти та логіку, пов'язану з ними. Всі сутності, їх властивості та методи, що відповідають за поведінку об'єктів у системі, визначені в цьому шарі. Важливою особливістю є те, що Model також містить класи для роботи з даними, які можуть бути пов'язані з базою даних через ORM Entity Framework Core або інший засіб для доступу до даних.
Controller:
Шар контролерів є посередником між Model та View. Контролери обробляють HTTP-запити, отримують необхідні дані з Model, а потім передають ці дані до відповідного представлення у View. Контролери також можуть виконувати операції з бізнес-логікою, такі як обробка даних перед їх відображенням або виконання дій на основі отриманих від користувача даних.
Data:
У папці Data зберігається інформація про базу даних. Це містить налаштування контексту бази даних, конфігурації ORM Entity Framework Core, а також реалізації репозиторіїв для доступу до даних. Цей шар є важливим для централізованого управління збереженням та доступом до даних у системі.
Використання архітектури MVC дозволяє чітко розділити відповідальність між різними частинами системи, що сприяє спрощенню підтримки, тестування та розширення функціональності. Завдяки слабкій зв'язності між компонентами, зміни в одному шарі не впливають на інші, що підвищує гнучкість і модульність системи.

3.3	Архітектура клієнтської частини

Архітектура клієнтської частини системи побудована з використанням платформи ASP.NET MVC та Razor Pages, які використовують мову програмування C# та платформу .NET 6. Такий підхід дозволяє створювати масштабовані веб-застосунки, що забезпечують інтерактивний і динамічний користувацький інтерфейс за допомогою серверної обробки сторінок.

Код застосунку поділено на контролери, моделі та представлення, відповідно до завдань, які виконуються цими частинами програми:

Головний модуль (Application module):

Усі контролери та представлення (Razor Pages) приєднуються до основного модулю, який управляє всім застосунком. Цей модуль забезпечує обробку запитів користувачів, управління маршрутизацією та виклик відповідних контролерів для обробки бізнес-логіки та відображення відповідних сторінок.
Маршрутизація:

Маршрутизація здійснюється за допомогою маршрутизатора ASP.NET MVC, який відповідає за обробку HTTP-запитів та визначення відповідних контролерів і представлень. Цей механізм дозволяє відображати різні сторінки (Razor Pages) залежно від запитів користувачів і параметрів URL.

Уся бізнес-логіка розподілена між різними контролерами, кожен з яких відповідає за окремий функціональний блок системи.
Представлення (Views/Razor Pages):

Представлення створюються за допомогою Razor Pages, що дозволяє інтегрувати C# код з HTML для генерації динамічних сторінок. Кожне представлення пов'язане з відповідною моделлю, яка надає дані для відображення, що забезпечує чітке розділення між логікою і відображенням.
Взаємодія між контролерами, моделями та представленнями у клієнтській частині забезпечує злагоджену роботу застосунку, де кожен компонент виконує свою роль у рамках архітектури MVC. Така структура дозволяє легко підтримувати, тестувати та розширювати застосунок, зберігаючи високу продуктивність та гнучкість системи.

3.4	Архітектура програмного забезпечення для розумних пристроїв


Для повноцінного функціонування програмної системи для організації змаганнь з веслування необхідна інтеграція розумних пристроїв.
Для реалізації функціоналу розумних пристроїв використовується мікроконтролер ESP32, для вимірювання часу виступу спортсмена. Для програмної реалізації була використана мова програмування C++, а також середовище Wokwi для імітації роботи та взаємодії розумних пристроїв. Додатково використовувалися бібліотеки для роботи з апаратною частиною та веб-взаємодією, такі як  WiFi.h, LiquidCrystal_I2C.h,ire.h, ArduinoJson.h, HTTPClient.h. 
	Мікроконтролер ESP32 містить вбудований модуль WiFi , що спрощує його взаємодією з іншими елементами системи. Перед заїздом кожному пристрою надається інформація про те який саме екіпаж виступає, а після виступу отримані дані передаються на сервер.

3.5 Архітектура мобільного застосунку

Для створення мобільного застосунку використовується мова програмування Kotlin та фреймворк Jetpack Compose, який є сучасним інструментом для побудови інтерфейсів на Android. Kotlin, будучи офіційною мовою для Android, дозволяє створювати продуктивні та зрозумілі коди, забезпечуючи високу продуктивність і зручність розробки.

Jetpack Compose використовується для побудови користувацьких інтерфейсів завдяки своїй декларативній природі, що дозволяє створювати гнучкі та динамічні інтерфейси. Це також забезпечує можливість роботи з даними в режимі реального часу завдяки реактивному програмуванню.

Основні компоненти архітектури:
UI (User Interface):

Усі інтерфейси користувача, включаючи композабельні функції для відображення даних, знаходяться в папці ui. Цей модуль відповідає за відображення інформації та взаємодію з користувачем.

Models:

Моделі, які містять бізнес-логіку та основні дані застосунку, розміщені в папці Model. Вони взаємодіють з ui та іншими сервісами, забезпечуючи доступ до даних та їхню обробку.

Зовнішні бібліотеки:

Додаток може використовувати різні зовнішні бібліотеки для забезпечення додаткових функцій, таких як робота з JSON (kotlinx.serialization), , робота з HTTP запитами ( Retrofit).














4РЕАЛІЗАЦІЯ ПРОГРАМНОЇ СИСТЕМИ

4.1	Реалізація серверної частини

Для розробки серверну частину програмної системи використано платформу .NET 6.0 та мову програмування C#, а також 	технологію ASP.NET Core для розробки Web API.
Для зберігання даних використовується база даних SQL Server. 	Доступ до даних з серверної частини застосунку відбувається за допомогою технології Entity Framework Core. 
Безпека даних підтримується завдяки хешуванню паролів за допомогою бібліотеки BCrypt.Net. Авторизація користувачів відбувається за допомогою зберігання їхніх захешованих даних в базі даних.
Інтернаціоналізація забезпечується шляхом підтримки різних часових поясів (усі дати на сервері зберігаються за часом UTC), можливості вибору різних одиниць вимірювання.
Забезпечено підтримку UTF-8 та ASCII і можливості передачі за зберігання інформації у базі даних різними мовами.
Під час розробки було використано деякі допоміжні пакети та фреймоворки, такі як Entity Framework Core, ASP.NET Core,   BCrypt.net.
Серверна частина розроблена за архітектурним стилем REST. Специфікація усіх кінцевих точок REST API наведена у таблиці 1.

4.2 Реалізація клієнтської частини

Для створення клієнтської частини використовується платформа ASP.NET MVC та Blazor, які підтримують мову програмування C#. Обидві технології забезпечують потужні можливості для розробки веб-застосунків із сучасним інтерфейсом.
Для забезпечення безпеки даних передбачено кілька механізмів. При введенні конфіденційних даних, таких як паролі, вони відображаються на екрані у вигляді, недоступному для читання. Для авторизації користувачів використовується механізм сесій, яка дозволяє зберігати сесію авторизації у зашифрованому вигляді. Передача паролів між клієнтом та сервером здійснюється у зашифрованому вигляді за допомогою SSL.
Фрагменти коду клієнтської частини, написаної на ASP.NET MVC та Blazor, наведені у додатку Б.

4.3	Реалізація програмного забезпечення для розумних пристроїв


Для реалізації функціоналу розумних пристроїв у системі " використовуються різноманітні апаратні та програмні компоненти. Основним контролером є мікроконтролер ESP32, який забезпечує збір і обробку даних з датчиків та зв'язок з іншими елементами системи.
Після конфігурування пристрій отримує інформацію про те, який екіпаж виступає. На основі цієї інформації здійснюється відлік часу виступу за допомогою команд "старт" та "фініш". Команда "старт" ініціює замір часу, а команда "фініш" завершує замір. Після завершення виступу дані про час передаються на сервер для подальшої обробки та збереження.
Для забезпечення інтернаціоналізації час у системі вимірюється в секундах. Це значення і передається далі на сервер.
Фрагменти коду програмного забезпечення для розумних пристроїв наведені у додатку В.

4.4 Реалізація мобільного застосунку

Мобільний застосунок створювався на платформі Android Studio з використанням мови програмування Kotlin.

У мобільному застосунку реалізовано функціонал для користувачів, зокрема для тренерів. Вони можуть змінювати дані профілю, взаємодіяти зі своїми веслувальниками та , відстежувати їх виступи, а також отримувати сповіщення про події.
Застосунок повністю інтегрований у систему. Усі зміни, які вносяться з Android-пристроїв, відображаються у браузерному клієнтському застосунку та у базі даних на сервері.

Фрагменти коду мобільного застосунку наведені у додатку Г.












5ОПИС СТВОРЕНОЇ СИСТЕМИ

5.1	Опис серверної частини


Реалізована серверна частина надає інтерфейс для взаємодії з іншими частинами системи у вигляді REST API.
Запуск серверного застосунку можливий на пристрої з виходом у мережу Інтернет та встановленим пакетом .NET Runtime з підтримкою ASP.NET Core. Перед цим необхідно налаштувати строку підключення до бази даних у конфігураційному файлі, а також встановити порти для запуску застосунку. 
Можлива публікація серверної частини у хмарний сервіс Azure засобами Visual Studio або вручну. Для цього необхідно створити відповідний простір у хмарі, створити у хмарі базу даних SQL Server, після цього розгорнути серверний застосунок з налаштованим рядком підключення до створеної бази даних.

Рисунок 5.1 - REST API серверу

5.2	Опис клієнтської частини


Клієнтська частина, створена за допомогою Blazor, надає користувачеві графічний інтерфейс для взаємодії з системою. Доступ до нього користувач може отримати через браузер, ввівши в адресний рядок адресу серверу, на якому розгорнуто клієнтський застосунок. У клієнтському браузерному застосунку реалізовано функціонал для усіх типів користувачів.

Рисунок 5.2 - форма входу веб-клієнта


Рисунок 5.3 - створення об’єкту на веб-клієнті


Рисунок 5.4 - реєстрація  на веб-клієнті


5.3	Опис взаємодії з розумними пристроями

Для реалізації функціоналу розумних пристроїв у системі " використовуються різноманітні апаратні та програмні компоненти. Основним контролером є мікроконтролер ESP32, який забезпечує збір і обробку даних з датчиків та зв'язок з іншими елементами системи.
Після конфігурування корстувач вводить  інформацію про те, який екіпаж виступає. На основі цієї інформації здійснюється відлік часу виступу за допомогою команд "старт" та "фініш". Команда "старт" ініціює замір часу, а команда "фініш" завершує замір. Після завершення виступу дані про час передаються на сервер для подальшої обробки та збереження.
Для забезпечення інтернаціоналізації час у системі вимірюється в секундах. Це значення і передається далі на сервер.

Рисунок 5.5 - введення екіпажу на пристрої ІоТ

Рисунок 5.6 - запуск таймеру на пристрої ІоТ


Рисунок 5.7 - результат заміру секундоміру на пристрої ІоТ

5.4	Опис взаємодії з мобільним застосунком

У мобільному застосунку реалізовано функціонал для користувачів, зокрема для тренерів. Вони можуть змінювати дані профілю, взаємодіяти зі своїми веслувальниками та  відстежувати їх виступи.
Застосунок повністю інтегрований у систему. Усі зміни, які вносяться з Android-пристроїв, відображаються у браузерному клієнтському застосунку та у базі даних на сервері.

Рисунок 5.8 - повідомлення помилки входу в Android клієнті


Рисунок 5.9 - успішний вхід в Android клієнті

Рисунок 5.10 - список спортсменів тренера в Android клієнті
  
Рисунок 5.11 - інформація про спортсмена в Android клієнті
 
Рисунок 5.12 - форма реєстрація для тренера в Android клієнті

Рисунок 5.13 - форма реєстрація для спортсмена в Android клієнті
















ВИСНОВОК


На курсовому проектуванні  на практиці було опановано, як проектувати архітектуру та будувати програмні системи з багатьма взаємопов’язаними компонентами, використовуючи різні технології в кожній із частин, використовуючи приклади побудови програмної системи для моніторингу та керування пасікою.
У цій роботі були визначені основні категорії користувачів системи (тренери, спортсмени, організатори) та їхні потреби. Результат аналізу являє собою детальний опис функцій, які повинні виконуватися в системі. Після цього була спроектована та побудована інформаційна система. Вона складається з серверної частини, що складається з бази даних, клієнтської частини браузера, розумних пристроїв і мобільного додатку. Усі частини системи розроблено відповідно до принципів чистої масштабованої архітектури. Також при проектуванні та розробці були враховані принципи DRY та ін.

Для побудови системи використовувалися різні технології. Для розробки серверу було використано  ASP.NET Core і .NET 8 за допомогою СУБД сервера MS SQL. Веб-застосунок було написано на  Blazor. Програмне забезпечення для смарт-пристроїв написано на C++ з використанням допоміжних бібліотек для програмування драйвера ESP-32. Мобільний додаток працює на Kotlin.

Розроблена система відповідає вимогам і потребам потенційних користувачів і може бути використана для автоматизації спортивних процесів.
ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ


1. Мартін Р. Чистий код: створення і рефакторинг за допомогою 
AGILE. – Харків: Фабула, 2019. – 416 с.
2. Krzystof Cwalina, Brad Abrams. Framework Design Guidelines: Conventions, Idioms, and Patterns for Reusable .NET Libraries. – Addison-Wesley Professional, 2009. – 436 p.
3. Мартін Р. Чиста архітектура: Мистецтво розроблення програмного забезпечення / пер. з англ. І. Бондар-Терещенко.  –  Харків: Фабула, 2021. – 
368 с.
4. Методичні вказівки до курсової роботи з навчальної дисципліни «Архітектура програмного забезпечення» для студентів усіх форм навчання спеціальності 121 – «Інженерія програмного забезпечення» / Упоряд. В.О. Лещинський, І.О. Лещинська, І.П. Сокорчук – Харків: ХНУРЕ, 2021. – 37 с.
5. .NET Documentation. URL: https://learn.microsoft.com/en-us/dotnet/ (Дата звернення 12.06.2024).
6. Функціональне тестування створеного програмного продукту. 
URL: https://www.youtube.com/watch?v=orDJIpLuuXw (Дата звернення 13.06.2024).
7. Репозиторій у віддаленій системі керування версіями. 
URL: https://github.com/NureTsvykVladyslav/apzkr-pzpi-21-6-tsvyk-vladyslav/ (Дата звернення 13.06.2024).


ДОДАТОК А
Фрагменти коду серверної частини
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using Server.Data;
using WebApplication3.Models;
using BC = BCrypt.Net.BCrypt;

namespace WebApplication3.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    public class AthletesController : ControllerBase
    {
        private readonly ServerContext _context;

        public AthletesController(ServerContext context)
        {
            _context = context;
        }

        // GET: api/Athletes
        [HttpGet]
        public async Task<ActionResult<IEnumerable<Athlete>>> GetAthletes()
        {
            return _context.Athlete != null ?
                      await _context.Athlete.ToListAsync() :
                      Problem("Entity set 'WebApplication3Context.Athlete' is null.");
        }
        // GET: api/Athletes/Me
        [HttpGet("Me")]
        public async Task<ActionResult<Coach>> GetAuthenticatedAthlete()
        {
            var athleteId = HttpContext.Session.GetInt32("AthleteId");
            if (athleteId == null)
            {
                return Unauthorized();
            }

            var athlete = await _context.Coach.FirstOrDefaultAsync(c => c.CoachId == athleteId);

            if (athlete == null)
            {
                return NotFound();
            }

            return athlete;
        }
        // GET: api/Athletes/5
        [HttpGet("{id}")]
        public async Task<ActionResult<Athlete>> GetAthlete(int? id)
        {
            if (id == null || _context.Athlete == null)
            {
                return NotFound();
            }

            var athlete = await _context.Athlete
                .FirstOrDefaultAsync(m => m.AthleteId == id);
            if (athlete == null)
            {
                return NotFound();
            }

            return athlete;
        }
        public class CompetitionWithCrewsDto
        {
            public int? CompetitionId { get; set; }
            public int? OrganizationId { get; set; }
            public int? CoachId { get; set; }
            public string CompetitionName { get; set; }
            public string CompetitionCountry { get; set; }
            public string CompetitionCity { get; set; }
            public DateTime RegistrationDeadline { get; set; }
            public DateTime CompetitionDate { get; set; }
            public List<CrewDto> Crews { get; set; }
        }

        public class CrewDto
        {
            public int CrewId { get; set; }
            public BoatType BoatType { get; set; }
            public int CompetitionId { get; set; }
            public int RaceId { get; set; }
            public int StartNumber { get; set; }
            public List<AthleteDto> Athletes { get; set; } // Список спортсменів
            public TimeSpan? TimeTaken { get; set; } // Додано час на змаганні (опціонально)
        }


        public class AthleteDto
        {
            public int AthleteId { get; set; }
            public string AthleteName { get; set; }
            // Додайте інші властивості спортсмена за потреби
        }
        public class CompetitionsResponseDto
        {
            public List<CompetitionWithCrewsDto> FutureCompetitions { get; set; }
            public List<CompetitionWithCrewsDto> Results { get; set; }
        }


        [HttpGet("GetCompetitionsByAthletes")]
        public async Task<ActionResult<CompetitionsResponseDto>> GetCompetitionsByAthletes(int? athleteId)
        {
            if (athleteId == null)
            {
                return NotFound();
            }

            // Знайти всі екіпажі, в яких є цей спортсмен
            var crewIds = await _context.CrewRower
                .Where(cr => cr.AthleteId == athleteId)
                .Select(cr => cr.CrewId)
                .ToListAsync();

            // Знайти всі змагання, де є ці екіпажі
            var allCompetitions = await _context.Competition
                .Where(c => _context.Crew.Any(crew => crew.CompetitionId == c.CompetitionId && crewIds.Contains(crew.CrewId)))
                .ToListAsync();

            // Розділити змагання на ті, що мають результати, і ті, що їх не мають
            var futureCompetitions = allCompetitions
    .Select(c => new CompetitionWithCrewsDto
    {
        CompetitionId = c.CompetitionId,
        OrganizationId = c.OrganizationId,
        CoachId = c.CoachId,
        CompetitionName = c.CompetitionName,
        CompetitionCountry = c.CompetitionCountry,
        CompetitionCity = c.CompetitionCity,
        RegistrationDeadline = c.RegistrationDeadline,
        CompetitionDate = c.CompetitioneDate,
        Crews = _context.Crew
            .Where(crew => crew.CompetitionId == c.CompetitionId &&
                           !_context.FinishedRace.Any(fr => fr.RaceId == crew.RaceId))
            .Select(crew => new CrewDto
            {
                CrewId = crew.CrewId,
                BoatType = crew.BoatType,
                CompetitionId = crew.CompetitionId,
                RaceId = crew.RaceId,
                StartNumber = crew.StartNumber,
                Athletes = _context.CrewRower
                    .Where(cr => cr.CrewId == crew.CrewId)
                    .Select(cr => new AthleteDto
                    {
                        AthleteId = cr.AthleteId,
                        AthleteName = _context.Athlete
                            .Where(a => a.AthleteId == cr.AthleteId)
                            .Select(a => a.AthleteName)
                            .FirstOrDefault()
                    })
                    .ToList(),
                TimeTaken = null // Немає результату, тому `TimeTaken` залишаємо як `null`
            })
            .ToList()
    })
    .Where(c => _context.Result.Any(r => _context.Crew.Any(cr => cr.CrewId == r.CrewId && cr.CompetitionId == c.CompetitionId)))
    .ToList();


            var results = allCompetitions
    .Select(c => new CompetitionWithCrewsDto
    {
        CompetitionId = c.CompetitionId,
        OrganizationId = c.OrganizationId,
        CoachId = c.CoachId,
        CompetitionName = c.CompetitionName,
        CompetitionCountry = c.CompetitionCountry,
        CompetitionCity = c.CompetitionCity,
        RegistrationDeadline = c.RegistrationDeadline,
        CompetitionDate = c.CompetitioneDate,
        Crews = _context.Crew
            .Where(crew => crew.CompetitionId == c.CompetitionId &&
                           _context.FinishedRace.Any(fr => fr.RaceId == crew.RaceId))
            .Select(crew => new CrewDto
            {
                CrewId = crew.CrewId,
                BoatType = crew.BoatType,
                CompetitionId = crew.CompetitionId,
                RaceId = crew.RaceId,
                StartNumber = crew.StartNumber,
                Athletes = _context.CrewRower
                    .Where(cr => cr.CrewId == crew.CrewId)
                    .Select(cr => new AthleteDto
                    {
                        AthleteId = cr.AthleteId,
                        AthleteName = _context.Athlete
                            .Where(a => a.AthleteId == cr.AthleteId)
                            .Select(a => a.AthleteName)
                            .FirstOrDefault()
                    })
                    .ToList(),
                TimeTaken = _context.Result
                                .Where(r => r.CrewId == crew.CrewId)
                                .Select(r => r.TimeTaken)
                                .FirstOrDefault() // Отримати перший результат (якщо існує)
            })
            .ToList()
    })
    .Where(c => _context.Result.Any(r => _context.Crew.Any(cr => cr.CrewId == r.CrewId && cr.CompetitionId == c.CompetitionId)))
    .ToList();

            var response = new CompetitionsResponseDto
            {
                FutureCompetitions = futureCompetitions,
                Results = results
            };

            return Ok(response);
        }


        // POST: api/Athletes
        [HttpPost]
        public async Task<ActionResult<Athlete>> CreateAthlete([Bind("AthleteId,AthleteName,Password,BirthDate,PhoneNumber,CoachId")] Athlete athlete)
        {
            if (ModelState.IsValid)
            {
                // Check if the coach referenced by CoachId exists in the database
                var coachExists = await _context.Coach.AnyAsync(c => c.CoachId == athlete.CoachId);
                if (!coachExists)
                {
                    ModelState.AddModelError("CoachId", "Такого тренера не існує.");
                    return BadRequest(ModelState);
                }

                // Hash the athlete's password before saving to the database
                athlete.Password = BC.HashPassword(athlete.Password);

                // Add athlete to the context and save changes
                _context.Add(athlete);
                await _context.SaveChangesAsync();

                // Return 201 Created status with the newly created athlete
                return CreatedAtAction(nameof(GetAthlete), new { id = athlete.AthleteId }, athlete);
            }

            // If ModelState is not valid, return bad request with ModelState errors
            return BadRequest(ModelState);
        }

        // PUT: api/Athletes/5
        [HttpPut("{id}")]
        public async Task<IActionResult> EditAthlete(int id, Athlete athlete)
        {
            if (id != athlete.AthleteId)
            {
                return BadRequest();
            }

            if (ModelState.IsValid)
            {
                try
                {
                    athlete.Password = BC.HashPassword(athlete.Password);
                    _context.Update(athlete);
                    await _context.SaveChangesAsync();
                }
                catch (DbUpdateConcurrencyException)
                {
                    if (!AthleteExists(athlete.AthleteId))
                    {
                        return NotFound();
                    }
                    else
                    {
                        throw;
                    }
                }
                return NoContent();
            }
            return BadRequest(ModelState);
        }

        // DELETE: api/Athletes/5
        [HttpDelete("{id}")]
        public async Task<IActionResult> DeleteAthlete(int id)
        {
            if (_context.Athlete == null)
            {
                return Problem("Entity set 'WebApplication3Context.Athlete' is null.");
            }

            var athlete = await _context.Athlete.FindAsync(id);
            if (athlete == null)
            {
                return NotFound();
            }

            _context.Athlete.Remove(athlete);
            await _context.SaveChangesAsync();

            return NoContent();
        }

        private bool AthleteExists(int id)
        {
            return _context.Athlete.Any(e => e.AthleteId == id);
        }
    }
}


using System.Linq;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using Server.Data;
using WebApplication3.Models;

namespace Server.Controllers
{
    [Route("api/[controller]")]
    [ApiController]
    public class CrewHandicapsController : ControllerBase
    {
        private readonly ServerContext _context;

        public CrewHandicapsController(ServerContext context)
        {
            _context = context;
        }

        // GET: api/CrewHandicaps
        [HttpGet]
        public async Task<ActionResult<IEnumerable<CrewHandicap>>> GetCrewHandicap()
        {
            if (_context.CrewHandicap == null)
            {
                return NotFound();
            }
            return await _context.CrewHandicap.ToListAsync();
        }

        // GET: api/CrewHandicaps/5
        [HttpGet("{id}")]
        public async Task<ActionResult<CrewHandicap>> GetCrewHandicap(int id)
        {
            if (_context.CrewHandicap == null)
            {
                return NotFound();
            }

            var crewHandicap = await _context.CrewHandicap.FindAsync(id);

            if (crewHandicap == null)
            {
                return NotFound();
            }

            return crewHandicap;
        }

        // PUT: api/CrewHandicaps/5
        [HttpPut("{id}")]
        public async Task<IActionResult> PutCrewHandicap(int id, CrewHandicap crewHandicap)
        {
            if (id != crewHandicap.CrewHandicapId)
            {
                return BadRequest();
            }

            // Перевірка наявності зовнішніх сутностей
            if (!await _context.Competition.AnyAsync(c => c.CompetitionId == crewHandicap.CompetitionId))
            {
                return BadRequest("Invalid CompetitionId.");
            }

            if (!await _context.RaceWithHandicap.AnyAsync(r => r.RaceWithHandicapId == crewHandicap.RaceWithHandicapId))
            {
                return BadRequest("Invalid RaceWithHandicapId.");
            }

            _context.Entry(crewHandicap).State = EntityState.Modified;

            try
            {
                await _context.SaveChangesAsync();
            }
            catch (DbUpdateConcurrencyException)
            {
                if (!CrewHandicapExists(crewHandicap.CrewHandicapId))
                {
                    return NotFound();
                }
                else
                {
                    throw;
                }
            }

            return NoContent();
        }

        // POST: api/CrewHandicaps
        [HttpPost]
        public async Task<ActionResult<CrewHandicap>> PostCrewHandicap(CrewHandicap crewHandicap)
        {
            if (_context.CrewHandicap == null)
            {
                return Problem("Entity set 'ServerContext.CrewHandicap'  is null.");
            }

            // Перевірка наявності зовнішніх сутностей
            if (!await _context.Competition.AnyAsync(c => c.CompetitionId == crewHandicap.CompetitionId))
            {
                return BadRequest("Invalid CompetitionId.");
            }

            if (!await _context.RaceWithHandicap.AnyAsync(r => r.RaceWithHandicapId == crewHandicap.RaceWithHandicapId))
            {
                return BadRequest("Invalid RaceWithHandicapId.");
            }

            _context.CrewHandicap.Add(crewHandicap);
            await _context.SaveChangesAsync();

            return CreatedAtAction("GetCrewHandicap", new { id = crewHandicap.CrewHandicapId }, crewHandicap);
        }

        // DELETE: api/CrewHandicaps/5
        [HttpDelete("{id}")]
        public async Task<IActionResult> DeleteCrewHandicap(int id)
        {
            if (_context.CrewHandicap == null)
            {
                return NotFound();
            }

            var crewHandicap = await _context.CrewHandicap.FindAsync(id);
            if (crewHandicap == null)
            {
                return NotFound();
            }

            _context.CrewHandicap.Remove(crewHandicap);
            await _context.SaveChangesAsync();

            return NoContent();
        }
        [HttpPost("assign-random-start-numbers/{raceWithHandicapId}")]
        public async Task<ActionResult> AssignRandomStartNumbers(int raceWithHandicapId)
        {
            try
            {
                var random = new Random();

                // Отримуємо всі CrewHandicap з заданим RaceWithHandicapId
                var crewHandicaps = await _context.CrewHandicap
                    .Where(ch => ch.RaceWithHandicapId == raceWithHandicapId)
                    .ToListAsync();

                if (crewHandicaps == null || !crewHandicaps.Any())
                {
                    Console.WriteLine("No CrewHandicaps found for the specified RaceWithHandicapId.");
                    return NotFound("No CrewHandicaps found for the specified RaceWithHandicapId.");
                }
                
                foreach (var crewHandicap in crewHandicaps)
                {
                    // Встановлюємо випадковий стартовий номер
                    crewHandicap.StartNumber = random.Next(1, 1000); // або будь-який інший діапазон, що вам потрібен
                }

                await _context.SaveChangesAsync();
                Console.WriteLine("Start numbers assigned successfully.");
                return Ok("Start numbers assigned successfully.");
            }
            catch (Exception ex)
            {
                // Логування помилки
                return StatusCode(500, $"Internal server error: {ex.Message}");
            }
        }

        private bool CrewHandicapExists(int id)
        {
            return (_context.CrewHandicap?.Any(e => e.CrewHandicapId == id)).GetValueOrDefault();
        }
    }
}
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.DependencyInjection;
using Server.Data;
var builder = WebApplication.CreateBuilder(args);
builder.Services.AddDbContext<ServerContext>(options =>
    options.UseSqlServer(builder.Configuration.GetConnectionString("ServerContext") ?? throw new InvalidOperationException("Connection string 'ServerContext' not found.")));

// Add services to the container.

builder.Services.AddControllers();
// Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/swashbuckle
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();

// Äîäàâàííÿ DataProtection òà ñåñ³é
builder.Services.AddDataProtection();
builder.Services.AddDistributedMemoryCache();
builder.Services.AddSession(options =>
{
    options.IdleTimeout = TimeSpan.FromMinutes(30);
    options.Cookie.HttpOnly = true;
    options.Cookie.IsEssential = true;
});

var app = builder.Build();

// Configure the HTTP request pipeline.
if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}

app.UseHttpsRedirection();

app.UseSession();

app.UseAuthorization();

app.MapControllers();

app.Run();















ДОДАТОК Б
Фрагменти коду клієнтської частини

@page
@model LoginViewModel
@{
}
<html>
<body>
   
    <h2>Форма входу</h2>
    @if (Model != null && !string.IsNullOrEmpty(Model.AlertMessage))
    {
        <div class="alert">
            @Model.AlertMessage
        </div>
    }
    <form action="/Login/LoginAll" method="post">
        <select name="role">
            <!-- Value should correspond to the roles you defined in LoginAll -->
            <option value="Тренер">Тренер</option>
            <option value="Спортсмен">Спортсмен</option>
            <option value="Фанат">Фанат</option>
            <option value="Організація">Організація</option>
        </select>
        <div>
            <label for="AthleteName">Ім'я:</label>
            <input type="text" id="AthleteName" name="name" required>
        </div>
        <div>
            <label for="Password">Пароль:</label>
            <input type="password" id="Password" name="password" required>
        </div>
        <div>
            <input type="submit" value="Увійти">
        </div>
    </form>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            background-color: #f4f4f4;
            margin: 0;
            padding: 0;
        }

        h2 {
            color: #333;
            text-align:center;
        }

        form {
            max-width: 400px;
            margin: 20px auto;
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }

        select, input {
            width: 100%;
            padding: 10px;
            margin-bottom: 15px;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-sizing: border-box;
        }

        label {
            display: block;
            margin-bottom: 8px;
            color: #333;
        }

        input[type="submit"] {
            background-color: #4caf50;
            color: #fff;
            cursor: pointer;
        }

            input[type="submit"]:hover {
                background-color: #45a049;
            }
    </style>
</body>
</html>
using System;
using System.Collections.Generic;
using System.Linq;
using System.Net.Http;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Options;
using Newtonsoft.Json;
using WebApplication3.Data;
using WebApplication3.Models;
using BC = BCrypt.Net.BCrypt;

namespace WebApplication3.Controllers
{
    public class CoachesController : Controller
    {
        private readonly IHttpClientFactory _httpClientFactory;
        private readonly ApiSettings _apiSettings;

        public CoachesController(IHttpClientFactory httpClientFactory, IOptions<ApiSettings> apiSettings)
        {
            _httpClientFactory = httpClientFactory;
            _apiSettings = apiSettings.Value;
        }

        // GET: Coaches
        public async Task<IActionResult> Index()
        {
            var client = _httpClientFactory.CreateClient();
            var response = await client.GetAsync($"{_apiSettings.BaseApiUrl}/Coaches");

            if (response.IsSuccessStatusCode)
            {
                var jsonData = await response.Content.ReadAsStringAsync();
                var coaches = JsonConvert.DeserializeObject<IEnumerable<Coach>>(jsonData);
                return View(coaches);
            }
            else
            {
                return Problem("Error fetching data from the API.");
            }
        }

        // GET: Coaches/Details/5
        public async Task<IActionResult> Details(int? id)
        {
            if (id == null)
            {
                return NotFound();
            }

            var client = _httpClientFactory.CreateClient();
            var response = await client.GetAsync($"{_apiSettings.BaseApiUrl}/Coaches/{id}");

            if (response.IsSuccessStatusCode)
            {
                var jsonData = await response.Content.ReadAsStringAsync();
                var coach = JsonConvert.DeserializeObject<Coach>(jsonData);
                if (coach == null)
                {
                    return NotFound();
                }
                return View(coach);
            }
            else
            {
                return Problem("Error fetching data from the API.");
            }
        }

        // GET: Coaches/Create
        public IActionResult Create()
        {
            return View();
        }

        // POST: Coaches/Create
        [HttpPost]
        [ValidateAntiForgeryToken]
        public async Task<IActionResult> Create([Bind("CoachId,CoachName,Password,BirthDate,PhoneNumber,Country")] Coach coach)
        {
            if (ModelState.IsValid)
            {
                var client = _httpClientFactory.CreateClient();
                coach.Password = BC.HashPassword(coach.Password);

                var content = new StringContent(JsonConvert.SerializeObject(coach), System.Text.Encoding.UTF8, "application/json");
                var response = await client.PostAsync($"{_apiSettings.BaseApiUrl}/Coaches", content);

                if (response.IsSuccessStatusCode)
                {
                    return RedirectToAction(nameof(Index));
                }
                else
                {
                    return Problem("Error creating the coach.");
                }
            }
            return View(coach);
        }

        // GET: Coaches/Edit/5
        public async Task<IActionResult> Edit(int? id)
        {
            if (id == null)
            {
                return NotFound();
            }

            var client = _httpClientFactory.CreateClient();
            var response = await client.GetAsync($"{_apiSettings.BaseApiUrl}/Coaches/{id}");

            if (response.IsSuccessStatusCode)
            {
                var jsonData = await response.Content.ReadAsStringAsync();
                var coach = JsonConvert.DeserializeObject<Coach>(jsonData);
                if (coach == null)
                {
                    return NotFound();
                }
                return View(coach);
            }
            else
            {
                return Problem("Error fetching data from the API.");
            }
        }

        // POST: Coaches/Edit/5
        [HttpPost]
        [ValidateAntiForgeryToken]
        public async Task<IActionResult> Edit(int id, [Bind("CoachId,CoachName,Password,BirthDate,PhoneNumber,Country,CoachSport")] Coach coach)
        {
            if (id != coach.CoachId)
            {
                return NotFound();
            }

            if (ModelState.IsValid)
            {
                var client = _httpClientFactory.CreateClient();
                var content = new StringContent(JsonConvert.SerializeObject(coach), System.Text.Encoding.UTF8, "application/json");
                var response = await client.PutAsync($"{_apiSettings.BaseApiUrl}/Coaches/{id}", content);

                if (response.IsSuccessStatusCode)
                {
                    return RedirectToAction(nameof(Index));
                }
                else
                {
                    return Problem("Error updating the coach.");
                }
            }
            return View(coach);
        }

        // GET: Coaches/Delete/5
        public async Task<IActionResult> Delete(int? id)
        {
            if (id == null)
            {
                return NotFound();
            }

            var client = _httpClientFactory.CreateClient();
            var response = await client.GetAsync($"{_apiSettings.BaseApiUrl}/Coaches/{id}");

            if (response.IsSuccessStatusCode)
            {
                var jsonData = await response.Content.ReadAsStringAsync();
                var coach = JsonConvert.DeserializeObject<Coach>(jsonData);
                if (coach == null)
                {
                    return NotFound();
                }
                return View(coach);
            }
            else
            {
                return Problem("Error fetching data from the API.");
            }
        }

        // POST: Coaches/Delete/5
        [HttpPost, ActionName("Delete")]
        [ValidateAntiForgeryToken]
        public async Task<IActionResult> DeleteConfirmed(int id)
        {
            var client = _httpClientFactory.CreateClient();
            var response = await client.DeleteAsync($"{_apiSettings.BaseApiUrl}/Coaches/{id}");

            if (response.IsSuccessStatusCode)
            {
                return RedirectToAction(nameof(Index));
            }
            else
            {
                return Problem("Error deleting the coach.");
            }
        }
    }
}



ДОДАТОК В
Фрагменти коду програмного забезпечення для розумних пристроїв
#include <WiFi.h>
#include <HTTPClient.h>
#include <Wire.h>
#include <LiquidCrystal_I2C.h>
#include <ArduinoJson.h>

LiquidCrystal_I2C LCD = LiquidCrystal_I2C(0x27, 16, 2);

unsigned long startTime;
bool timerRunning = false;
int crewId = 0;

void spinner() {
  static int8_t counter = 0;
  const char* glyphs = "\xa1\xa5\xdb";
  LCD.setCursor(15, 1);
  LCD.print(glyphs[counter++]);
  if (counter == strlen(glyphs)) {
    counter = 0;
  }
}

void startTimer() {
  startTime = millis();
  timerRunning = true;
  LCD.clear();
  LCD.setCursor(0, 0);
  LCD.print("Timer started");
}

void stopTimer() {
  if (timerRunning) {
    unsigned long elapsedTime = millis() - startTime;
    timerRunning = false;

    LCD.clear();
    LCD.setCursor(0, 0);
    LCD.print("Time taken:");
    LCD.setCursor(0, 1);
    LCD.print(elapsedTime / 1000.0, 2); // Display time in seconds

    delay(2000);
    
    sendResultToServer(crewId, elapsedTime);
  }
}

void sendResultToServer(int crewId, unsigned long timeTaken) {
  HTTPClient http;
  http.begin("https://localhost:7178.azurewebsites.net/api/Result"); // Change URL to your local server
  //https://azureveb20240521093611.azurewebsites.net/api/Result
  http.addHeader("Content-Type", "application/json");

  // Forming JSON
  DynamicJsonDocument doc(1024);
  doc["CrewId"] = crewId;
  doc["TimeTaken"] = timeTaken / 1000.0; // Convert to seconds

  String requestBody;
  serializeJson(doc, requestBody);

  // Sending POST request
  int httpResponseCode = http.POST(requestBody);

  if (httpResponseCode > 0) {
    if (httpResponseCode == HTTP_CODE_OK) {
      String response = http.getString();
      Serial.println("Response: " + response);
      LCD.clear();
      LCD.setCursor(0, 0);
      LCD.print("Result sent");
    }
  } else {
    Serial.println("Error sending POST request");
    LCD.clear();
    LCD.setCursor(0, 0);
    LCD.print("Error sending");
  }

  http.end();
}

void setup() {
  Serial.begin(115200);

  LCD.init();
  LCD.backlight();
  LCD.setCursor(0, 0);
  LCD.print("Connecting to ");
  LCD.setCursor(0, 1);
  LCD.print("WiFi ");

  WiFi.begin("Wokwi-GUEST", "", 6);
  while (WiFi.status() != WL_CONNECTED) {
    delay(250);
    spinner();
  }

  Serial.println("");
  Serial.println("WiFi connected");
  Serial.print("IP address: ");
  Serial.println(WiFi.localIP());

  LCD.clear();
  LCD.setCursor(0, 0);
  LCD.println("Online");
  LCD.setCursor(0, 1);
  LCD.println("Ready");

  // Simulate getting CrewId from the user
  Serial.println("Enter CrewId:");
  while (Serial.available() == 0) {} // Wait for input
  crewId = Serial.parseInt();
  Serial.print("CrewId: ");
  Serial.println(crewId);

  // Start the timer
  startTimer();
}

void loop() {
  // Logic to stop the timer through button press or other trigger
  if (Serial.available()) { // Serial monitor used to simulate stop trigger
    char command = Serial.read();
    if (command == 's') {
      stopTimer();
    }
  }

  delay(250);
}









ДОДАТОК Г
Фрагменти коду мобільного застосунку
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="vertical"
    android:padding="16dp">

    <TextView
        android:id="@+id/athleteNameTextView"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Athlete Name"
        android:textSize="16sp" />

    <TextView
        android:id="@+id/birthDateTextView"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Birth Date"
        android:visibility="gone"
        android:textSize="14sp" />

    <Button
        android:id="@+id/moreDetailsButton"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Детальніше" />

    <TextView
        android:id="@+id/competitionsTextView"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:visibility="gone"
        android:textSize="14sp" />

    <!-- Додайте інші поля за потреби -->

</LinearLayout>

package com.example.sportapp.Model

import android.util.Log
import com.example.sportapp.ui.home.LoginRequest
import com.example.sportapp.ui.home.LoginResponse
import okhttp3.OkHttpClient
import okhttp3.logging.HttpLoggingInterceptor
import retrofit2.Response
import retrofit2.http.Body
import retrofit2.http.GET
import retrofit2.http.Headers
import retrofit2.http.POST
import retrofit2.http.Query
import java.security.cert.CertificateException
import java.util.Date
import javax.net.ssl.SSLContext
import javax.net.ssl.TrustManager
import javax.net.ssl.X509TrustManager
import com.google.gson.annotations.SerializedName
import com.google.gson.reflect.TypeToken
import com.google.gson.Gson
import com.google.gson.*
import retrofit2.http.Path
import java.lang.reflect.Type
import java.text.SimpleDateFormat
import java.util.*
interface ApiService {
    @Headers("Content-Type: application/json", "accept: text/plain")
    @POST("/api/Login")
    suspend fun login(@Body request: LoginRequest): Response<LoginResponse>

    @Headers("Content-Type: application/json", "accept: text/plain")
    @POST("/api/Coaches")
    suspend fun registerCoach(@Body request: CoachRegistrationRequest): Response<CoachRegistrationResponse>

    @Headers("Content-Type: application/json", "accept: text/plain")
    @POST("/api/Athletes")
    suspend fun registerAthlete(@Body request: AthleteRegistrationRequest): Response<AthleteRegistrationResponse>

    @GET("/api/Athletes/Me")
    suspend fun getMyAthleteInfo(): Response<Athlete>

    @GET("/api/Coaches/Me")
    suspend fun getMyCoachInfo(): Response<Coach>

    @Headers("Accept: application/json")
    @GET("/api/Coaches/GetAthletesByCoach")
    suspend fun getMyAthletes(@Query("coachId") coachId: Int): Response<List<Athlete>>

    @Headers("Accept: application/json")
    @GET("/api/Athletes/GetCompetitionsByAthletes")
    suspend fun getAthletesCompetitions(@Query("athleteId") athleteId: Int): Response<CompetitionsResponse>

    @Headers("Accept: application/json")
    @GET("/api/Athletes/{id}")
    suspend fun getAthleteById(@Path("id") athleteId: Int): Response<Athlete>

    @GET("/api/Coaches")
    suspend fun getCoaches(): Response<List<Coach>>

    @POST("/api/Login/logout")
    suspend fun logout(): Response<Void>
}

fun getUnsafeOkHttpClient(): OkHttpClient {
    return try {
        val trustAllCerts = arrayOf<TrustManager>(
            object : X509TrustManager {
                @Throws(CertificateException::class)
                override fun checkClientTrusted(chain: Array<java.security.cert.X509Certificate>, authType: String) {}

                @Throws(CertificateException::class)
                override fun checkServerTrusted(chain: Array<java.security.cert.X509Certificate>, authType: String) {}

                override fun getAcceptedIssuers(): Array<java.security.cert.X509Certificate> {
                    return arrayOf()
                }
            }
        )

        val sslContext = SSLContext.getInstance("SSL")
        sslContext.init(null, trustAllCerts, java.security.SecureRandom())
        val sslSocketFactory = sslContext.socketFactory

        val logging = HttpLoggingInterceptor().apply {
            level = HttpLoggingInterceptor.Level.BODY
        }

        val builder = OkHttpClient.Builder()
            .sslSocketFactory(sslSocketFactory, trustAllCerts[0] as X509TrustManager)
            .hostnameVerifier { _, _ -> true }
            .addInterceptor(logging)

        builder.build()
    } catch (e: Exception) {
        throw RuntimeException(e)
    }
}

package com.example.sportapp.ui.profile

import android.util.Log
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.Button
import android.widget.TextView
import androidx.recyclerview.widget.RecyclerView
import com.example.sportapp.Model.*
import com.example.sportapp.R
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import retrofit2.HttpException

class AthleteAdapter(
    private var athletes: List<Athlete>,
    private val api: ApiService
) : RecyclerView.Adapter<AthleteAdapter.AthleteViewHolder>() {

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): AthleteViewHolder {
        val view = LayoutInflater.from(parent.context).inflate(R.layout.item_athlete, parent, false)
        return AthleteViewHolder(view)
    }

    override fun onBindViewHolder(holder: AthleteViewHolder, position: Int) {
        val athlete = athletes[position]
        holder.nameTextView.text = athlete.athleteName
        holder.birthDateTextView.text = formatToISO8601(athlete.birthDate)

        // Manage the details visibility state
        var isDetailsVisible = false

        holder.moreDetailsButton.setOnClickListener {
            if (isDetailsVisible) {
                // Hide detailed information
                holder.competitionsTextView.visibility = View.GONE
                holder.moreDetailsButton.text = "Детальніше"
                isDetailsVisible = false
            } else {
                // Show detailed information
                CoroutineScope(Dispatchers.IO).launch {
                    try {
                        Log.d("AthleteAdapter", "Fetching competitions for athleteId: ${athlete.athleteId}")
                        val response = athlete.athleteId?.let { id -> api.getAthletesCompetitions(id) }
                        if (response != null) {
                            if (response.isSuccessful) {
                                val competitionsResponse = response.body()
                                val futureCompetitions = competitionsResponse?.futureCompetitions ?: emptyList()
                                val pastCompetitions = competitionsResponse?.results ?: emptyList()

                                Log.d("AthleteAdapter", "Competitions fetched successfully: $futureCompetitions, $pastCompetitions")

                                withContext(Dispatchers.Main) {
                                    val futureCompetitionsText = futureCompetitions.joinToString("\n\n") { competition ->
                                        val crewsInfo = competition.crews.joinToString("\n") { crew ->
                                            val athletesInfo = crew.athletes.joinToString(", ") { athlete -> athlete.athleteName }
                                            "       Crew Start Number: ${crew.startNumber}\n" +
                                                    "       Boat Type: ${crew.boatType}\n" +
                                                    "       Athletes: $athletesInfo\n"
                                        }
                                        "   Competition Name: ${competition.competitionName}\n" +
                                                "   City: ${competition.competitionCity}\n" +
                                                "   Country: ${competition.competitionCountry}\n" +
                                                "   Crews:\n$crewsInfo"
                                    }

                                    val pastCompetitionsText = pastCompetitions.joinToString("\n\n") { competition ->
                                        val crewsInfo = competition.crews.joinToString("\n") { crew ->
                                            val athletesInfo = crew.athletes.joinToString(", ") { athlete -> athlete.athleteName }
                                            "    Crew Start Number: ${crew.startNumber}\n" +
                                                    "   Boat Type: ${crew.boatType}\n" +
                                                    "   Athletes: $athletesInfo\n"+
                                                    "       Time Taken: ${crew.timeTaken}"
                                        }
                                        "   Competition Name: ${competition.competitionName}\n" +
                                                "   City: ${competition.competitionCity}\n" +
                                                "   Country: ${competition.competitionCountry}\n" +
                                                "   Crews:\n$crewsInfo"
                                    }

                                    holder.competitionsTextView.text = "Future Competitions:\n$futureCompetitionsText\n\nPast Competitions:\n$pastCompetitionsText"
                                    holder.competitionsTextView.visibility = View.VISIBLE
                                    holder.moreDetailsButton.text = "Менше"
                                    isDetailsVisible = true
                                }
                            } else {
                                Log.e("AthleteAdapter", "Failed to fetch competitions. Response code: ${response.code()}")
                                withContext(Dispatchers.Main) {
                                    holder.competitionsTextView.text = "Не вдалося завантажити змагання."
                                    holder.competitionsTextView.visibility = View.VISIBLE
                                    holder.moreDetailsButton.text = "Менше"
                                    isDetailsVisible = true
                                }
                            }
                        } else {
                            Log.e("AthleteAdapter", "Response is null for athleteId: ${athlete.athleteId}")
                            withContext(Dispatchers.Main) {
                                holder.competitionsTextView.text = "Не вдалося завантажити змагання."
                                holder.competitionsTextView.visibility = View.VISIBLE
                                holder.moreDetailsButton.text = "Менше"
                                isDetailsVisible = true
                            }
                        }
                    } catch (e: HttpException) {
                        Log.e("AthleteAdapter", "HttpException: ${e.message()}", e)
                        withContext(Dispatchers.Main) {
                            holder.competitionsTextView.text = "Помилка мережі: ${e.message}"
                            holder.competitionsTextView.visibility = View.VISIBLE
                            holder.moreDetailsButton.text = "Менше"
                            isDetailsVisible = true
                        }
                    } catch (e: Exception) {
                        Log.e("AthleteAdapter", "Exception: ${e.message}", e)
                        withContext(Dispatchers.Main) {
                            holder.competitionsTextView.text = "Помилка: ${e.message}"
                            holder.competitionsTextView.visibility = View.VISIBLE
                            holder.moreDetailsButton.text = "Менше"
                            isDetailsVisible = true
                        }
                    }
                }
            }
        }
    }

    override fun getItemCount(): Int = athletes.size

    fun updateAthletes(newAthletes: List<Athlete>) {
        athletes = newAthletes
        notifyDataSetChanged()
    }

    class AthleteViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {
        val nameTextView: TextView = itemView.findViewById(R.id.athleteNameTextView)
        val birthDateTextView: TextView = itemView.findViewById(R.id.birthDateTextView)
        val moreDetailsButton: Button = itemView.findViewById(R.id.moreDetailsButton)
        val competitionsTextView: TextView = itemView.findViewById(R.id.competitionsTextView)
    }
}
